
import numpy as np
import pandas as pd
import plotly.express as px
import scipy.stats as stats
import streamlit as st
import carrega_dados  # Importa fun√ß√£o de carregamento de dados

# üîπ Carregar os dados
df = carrega_dados.carregar_dados()

def main ():
    # üîπ Lista das vari√°veis categ√≥ricas
    variaveis_categoricas = ["make", "model", "trim", "body", "transmission", "state", "color", "interior", "seller"]

    # üîπ Configura√ß√£o de layout do Streamlit com abas estilizadas
    st.markdown("""
        <style>
            /* Fundo da aplica√ß√£o */
            .stApp {
                background-color: #f8f9fa;
            }

            /* Estilo das m√©tricas */
            .stMetric {
                font-size: 22px;
                font-weight: bold;
                color: #333333;
            }

            /* Tabela */
            table {
                border-collapse: collapse;
                width: 100%;
            }

            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }

            th {
                background-color: #f2f2f2;
                font-weight: bold;
            }

            /* Estilo customizado para as abas */
            .stTabs [data-baseweb="tab"] {
                font-size: 17px;
                color: #495057;
                background-color: #e9ecef;
                padding: 10px 20px;
                margin-right: 6px;
                border-radius: 10px 10px 0 0;
                border: 1px solid #dee2e6;
                transition: all 0.3s ease-in-out;
            }

            .stTabs [aria-selected="true"] {
                background-color: #ffffff;
                color: #d6336c;
                font-weight: 600;
                border-bottom: none;
                box-shadow: 0 -3px 0 #d6336c inset;
            }
        </style>
    """, unsafe_allow_html=True)

    # üî∏ T√≠tulo da aplica√ß√£o
    st.title("Dashboard de An√°lise de Vendas")

    # üîπ Abas com t√≠tulos e √≠cones
    aba1, aba2, aba3 = st.tabs(["üìà Vis√£o Geral", "üìã An√°lise Isolada", "üßÆ Matriz Correla√ß√£o"])

    # üîπ Lista das vari√°veis categ√≥ricas
    variaveis_categoricas = ["make", "model", "trim", "body", "transmission", "state", "color", "interior", "seller"]

    with aba1:
        st.subheader("üìã Top Frequ√™ncia")


        # Dicion√°rio para traduzir os nomes das vari√°veis
        nomes_traduzidos = {
            "year": "Ano",
            "make": "Marca",
            "model": "Modelo",
            "trim": "Especifica√ß√£o",
            "body": "Segmento do Carro",
            "transmission": "Transmiss√£o",
            "vin": "ID",
            "state": "Estado",
            "condition": "Condi√ß√£o do Carro",
            "odometer": "Kilometros do Carro",
            "color": "Cor do Carro",
            "interior": "Cor do Interior",
            "seller": "Vendedor",
            "mmr": "Valor de Mercado",
            "sellingprice": "Pre√ßo de Venda"
            # Adiciona mais conforme necess√°rio
        }

        num_categorias = st.slider("N√∫mero de categorias", min_value=3, max_value=20, value=10)

        # Se ainda n√£o existir o estado 'figs_para_pdf' em session_state, criamos uma lista vazia
        if 'figs_para_pdf' not in st.session_state:
            st.session_state.figs_para_pdf = []

        i = 0
        while i < len(variaveis_categoricas):
            if i == len(variaveis_categoricas) - 1:
                col = st.columns([0.7, 0.3])[0]
            else:
                col1, col2 = st.columns(2)

            for j, col in enumerate([col1, col2] if i < len(variaveis_categoricas) - 1 else [col]):
                if i + j < len(variaveis_categoricas):
                    variavel = variaveis_categoricas[i + j]
                    if variavel in df.columns:
                        frequencias = df[variavel].value_counts().head(num_categorias)
                        labels_curto = [x[:10] + "..." if len(x) > 10 else x for x in frequencias.index]

                        nome_exibido = nomes_traduzidos.get(variavel, variavel.capitalize())

                        with col:
                            st.subheader(f"üìå {nome_exibido}")

                            # üìå Gr√°fico de donut para 'transmission'
                            if variavel == "transmission":
                                fig_donut = px.pie(
                                    values=frequencias.values,
                                    names=labels_curto,
                                    hole=0.5,
                                    title=f"Distribui√ß√£o de {nome_exibido}",
                                    color_discrete_sequence=px.colors.qualitative.Prism
                                )
                                fig_donut.update_layout(
                                    paper_bgcolor='rgba(0,0,0,0)',
                                    plot_bgcolor='rgba(0,0,0,0)',
                                )
                                st.plotly_chart(fig_donut, use_container_width=True)
                                st.session_state.figs_para_pdf.append(fig_donut)  # Adiciona √† lista de gr√°ficos

                            else:
                                # üìä Gr√°fico de barras
                                fig_bar = px.bar(
                                    x=labels_curto,
                                    y=frequencias.values,
                                    text=frequencias.values,
                                    labels={'x': nome_exibido, 'y': 'Frequ√™ncia'},
                                    title=f"Top {num_categorias} categorias - {nome_exibido}",
                                    color=frequencias.index,
                                    color_discrete_sequence=px.colors.qualitative.Prism
                                )
                                fig_bar.update_traces(textposition='outside')
                                fig_bar.update_layout(
                                    plot_bgcolor='rgba(0,0,0,0)',
                                    paper_bgcolor='rgba(0,0,0,0)',
                                    font=dict(color="black")
                                )
                                st.plotly_chart(fig_bar, use_container_width=True)
                                st.session_state.figs_para_pdf.append(fig_bar)  # Adiciona √† lista de gr√°ficos

            i += 2


        # Verificando se os gr√°ficos foram gerados
        if not st.session_state.figs_para_pdf:
            st.warning("Nenhum gr√°fico foi gerado para o PDF.")  # Mensagem de aviso caso a lista esteja vazia
        st.markdown("---")
        st.caption("¬© 2025 AutoImport Portugal. Todos os direitos reservados.")


    # üîπ ABA - An√°lise Estat√≠stica Profissional
    with aba2:

        # Mapeamento dos nomes das vari√°veis
        variable_names = {
            "year": "Ano",
            "make": "Marca",
            "model": "Modelo",
            "trim": "Especifica√ß√£o",
            "body": "Segmento do Carro",
            "transmission": "Transmiss√£o",
            "vin": "ID",
            "state": "Estado",
            "condition": "Condi√ß√£o do Carro",
            "odometer": "Kilometros do Carro",
            "color": "Cor do Carro",
            "interior": "Cor do Interior",
            "seller": "Vendedor",
            "mmr": "Valor de Mercado",
            "sellingprice": "Pre√ßo de Venda"
        }

        # Reverter o dicion√°rio para facilitar a tradu√ß√£o
        reverse_variable_names = {v: k for k, v in variable_names.items()}

        st.write("### üîç An√°lise Isolada de Vari√°veis")

        # Exibir o dropdown com os nomes amig√°veis
        variable = st.selectbox(
            "Selecione uma vari√°vel para analisar",
            list(variable_names.values())
        )

        # Mapeia o nome amig√°vel de volta para o nome real da coluna
        real_variable = reverse_variable_names[variable]

        # Descri√ß√µes das vari√°veis
        descriptions = {
            "year": "üìÖ Representa o ano de fabrico do ve√≠culo, sendo um indicador crucial para determinar a idade, o valor de mercado e poss√≠veis atualiza√ß√µes tecnol√≥gicas ou regulamentares associadas √† sua produ√ß√£o.",
            "make": "üè≠ Refere-se ao fabricante do ve√≠culo, identificando a empresa respons√°vel pela sua cria√ß√£o. A marca pode transmitir valores relacionados √† qualidade, inova√ß√£o e reputa√ß√£o no mercado autom√≥vel.",
            "model": "üöó Designa a designa√ß√£o espec√≠fica do ve√≠culo dentro da linha da marca, distinguindo-o de outras variantes e influenciando a sua posi√ß√£o competitiva e perce√ß√£o de valor.",
            "trim": "üîß Indica o n√≠vel de acabamento ou a configura√ß√£o escolhida para o ve√≠culo, que pode incluir op√ß√µes e caracter√≠sticas adicionais que diferenciam as variantes em termos de conforto, tecnologia e desempenho.",
            "body": "üöô Define o tipo de carro√ßaria do ve√≠culo, descrevendo a sua estrutura e design, o que afeta a funcionalidade, o espa√ßo interior e a din√¢mica de condu√ß√£o.",
            "transmission": "‚öôÔ∏è Especifica o sistema de transmiss√£o, autom√°tico ou manual. Esta caracter√≠stica determina como a pot√™ncia √© transmitida para as rodas e influencia a experi√™ncia de condu√ß√£o e a efici√™ncia do ve√≠culo.",
            "vin": "üîë Trata-se de um c√≥digo √∫nico atribu√≠do a cada ve√≠culo, essencial para a verifica√ß√£o da sua autenticidade, rastreamento do hist√≥rico e registo de manuten√ß√£o ao longo do tempo.",
            "state": "üåç Indica o estado de onde o ve√≠culo est√° dispon√≠vel, fornecendo a localiza√ß√£o geogr√°fica que pode ser relevante para quest√µes de log√≠stica, transporte e acesso ao autom√≥vel.",
            "condition": "üîç Avalia o estado geral do ve√≠culo, considerando fatores como desgaste, manuten√ß√£o e eventuais danos, expressa atrav√©s de uma escala que facilita a compara√ß√£o entre diferentes exemplares.",
            "odometer": "üìè Regista a dist√¢ncia total percorrida pelo ve√≠culo, um par√¢metro fundamental para estimar o n√≠vel de utiliza√ß√£o e, consequentemente, o desgaste mec√¢nico e a deprecia√ß√£o do autom√≥vel.",
            "color": "üé® Descreve a cor predominante da pintura do ve√≠culo, um aspeto que pode influenciar tanto a est√©tica como a prefer√™ncia dos potenciais compradores.",
            "interior": "üõãÔ∏è Detalha a cor e os materiais empregados no interior do ve√≠culo, refletindo a qualidade, o conforto e o estilo do design interno, elementos que impactam a experi√™ncia do utilizador.",
            "seller": "üë§ Identifica a entidade ou indiv√≠duo respons√°vel pela venda do ve√≠culo, sendo um fator relevante na avalia√ß√£o da credibilidade e da transpar√™ncia na transa√ß√£o.",
            "mmr": "üí∞ Fornece uma estimativa do valor de mercado do ve√≠culo, baseada em an√°lises de dados hist√≥ricos de transa√ß√µes e leil√µes, servindo como refer√™ncia para avalia√ß√µes e negocia√ß√µes."
        }

        st.markdown(f"<h><strong>Descri√ß√£o:</strong></h4><p style='font-size:20px'>{descriptions[real_variable]}</p>", unsafe_allow_html=True)



        frequencias = df[real_variable].value_counts().reset_index()
        frequencias.columns = [real_variable, "Frequ√™ncia"]

        # Criar coluna de porcentagem
        frequencias["% do Total"] = (frequencias["Frequ√™ncia"] / frequencias["Frequ√™ncia"].sum() * 100).round(2)

        # Criar layout com m√©tricas destacadas
        col1, col2, col3 = st.columns(3)

        with col1:
            st.metric("Moda (Mais comum)", frequencias.iloc[0, 0])

        with col2:
            st.metric("M√©dia de Ocorr√™ncias", f"{frequencias['Frequ√™ncia'].mean():,.0f}")

        with col3:
            st.metric("Mediana de Ocorr√™ncias", f"{frequencias['Frequ√™ncia'].median():,.0f}")

        # Adicionar o slider para definir o n√∫mero de categorias a exibir
        top_n = st.slider("N√∫mero de categorias para o gr√°fico:", min_value=1, max_value=20, value=10)

        # Se for vari√°vel num√©rica, mostrar distribui√ß√£o
        if df[real_variable].dtype in ['int64', 'float64']:
            top_n_counts = df[real_variable].value_counts().nlargest(top_n)

            fig = px.bar(
                x=top_n_counts.index,
                y=top_n_counts.values,
                text=top_n_counts.values,
                labels={'x': real_variable, 'y': 'Frequ√™ncia'},
                title=f"Distribui√ß√£o de {real_variable}",
                color=top_n_counts.index,  # Cor autom√°tica para cada barra
                color_discrete_sequence=px.colors.qualitative.Prism
            )

        else:
            # Para vari√°veis categ√≥ricas, mostrar os top N valores
            category_counts = df[real_variable].value_counts().nlargest(top_n)

            fig = px.bar(
                x=category_counts.values,
                y=category_counts.index,
                text=category_counts.values,
                labels={'x': 'Frequ√™ncia', 'y': real_variable},
                title=f"Top {top_n} categorias - {real_variable}",
                orientation='h',
                color=category_counts.index,  # Cor autom√°tica para cada barra
                color_discrete_sequence=px.colors.qualitative.Prism
            )

        # Melhorias no layout
        fig.update_traces(textposition='outside')
        fig.update_layout(
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            font=dict(color="black")
        )

        # Exibir gr√°fico no Streamlit
        st.plotly_chart(fig, use_container_width=True)

        # An√°lise estat√≠stica para vari√°veis num√©ricas com emojis
        if df[real_variable].dtype in ['int64', 'float64']:
            # st.write("**üìä Estat√≠sticas Descritivas:**")
            # st.write(f"üî¢ **M√©dia**: {df[real_variable].mean():.2f}")
            # st.write(f"üìè **Desvio Padr√£o**: {df[real_variable].std():.2f}")
            # st.write(f"üìâ **M√≠nimo**: {df[real_variable].min()}")
            # st.write(f"üìà **M√°ximo**: {df[real_variable].max()}")
            # st.write(f"üîò **Mediana**: {df[real_variable].median()}")

            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("üìä M√©dia", f"{df[real_variable].mean():,.2f}")
                st.metric("üìâ M√≠nimo", f"{df[real_variable].min():,.2f}")

            with col2:
                st.metric("üìè Desvio Padr√£o", f"{df[real_variable].std():,.2f}")
                st.metric("üìà M√°ximo", f"{df[real_variable].max():,.2f}")

            with col3:
                st.metric("üîò Mediana", f"{df[real_variable].median():,.2f}")
                st.metric("üìä Intervalo Interquartil",
                            f"{df[real_variable].quantile(0.75) - df[real_variable].quantile(0.25):,.2f}")

            st.write(f"üî† **Quartil 1 (25%)**: {df[real_variable].quantile(0.25)}")
            st.write(f"üî° **Quartil 3 (75%)**: {df[real_variable].quantile(0.75)}")





        else:
            # Para vari√°veis categ√≥ricas, mostrar contagens paginadas (3 por linha)
            st.write("**üìä An√°lise de Contagem:**")

            # Obt√©m todas as contagens de categorias
            category_counts = df[real_variable].value_counts()

            # Definir o tamanho da p√°gina
            page_size = 21  # M√∫ltiplo de 3 para garantir linhas completas
            total_pages = -(-len(category_counts) // page_size)  # Arredonda para cima

            # Criar estado para armazenar a p√°gina atual
            if "page_number" not in st.session_state:
                st.session_state.page_number = 1

            # Calcula os √≠ndices para exibi√ß√£o
            start_idx = (st.session_state.page_number - 1) * page_size
            end_idx = start_idx + page_size
            display_counts = category_counts[start_idx:end_idx]

            # Exibir os valores 3 por linha
            cols = st.columns(3)  # Cria 3 colunas
            for i, (category, count) in enumerate(display_counts.items()):
                with cols[i % 3]:  # Distribui entre as colunas
                    st.write(f"üî¢ **{category}:** {count}")

            # Criar os bot√µes de pagina√ß√£o
            col1, col2, col3 = st.columns([1, 2, 1])

            # Bot√£o "Anterior"
            if col1.button("‚¨Ö Anterior", disabled=(st.session_state.page_number == 1)):
                st.session_state.page_number -= 1

            # Mostrar a p√°gina atual
            col2.write(f"üìÑ P√°gina {st.session_state.page_number} de {total_pages}")

            # Bot√£o "Pr√≥xima"
            if col3.button("Pr√≥xima ‚û°", disabled=(st.session_state.page_number == total_pages)):
                st.session_state.page_number += 1



    with aba3:
        # Dicion√°rio de tradu√ß√£o (pode estar declarado fora para reutiliza√ß√£o geral)
        nomes_traduzidos = {
            "year": "Ano",
            "make": "Marca",
            "model": "Modelo",
            "trim": "Especifica√ß√£o",
            "body": "Segmento do Carro",
            "transmission": "Transmiss√£o",
            "vin": "ID",
            "state": "Estado",
            "condition": "Condi√ß√£o do Carro",
            "odometer": "Km",
            "color": "Cor do Carro",
            "interior": "Cor do Interior",
            "seller": "Vendedor",
            "mmr": "Valor de Mercado",
            "sellingprice": "Pre√ßo"
        }

        # Inverso do dicion√°rio para obter o nome t√©cnico a partir do nome traduzido
        nomes_invertidos = {v: k for k, v in nomes_traduzidos.items()}

        st.subheader("üîó Matriz de Correla√ß√£o")


        def cramers_v(x, y):
            """Calcula a correla√ß√£o de Cram√©r's V entre duas vari√°veis categ√≥ricas."""
            confusion_matrix = pd.crosstab(x, y)
            chi2 = stats.chi2_contingency(confusion_matrix)[0]
            n = confusion_matrix.sum().sum()
            min_dim = min(confusion_matrix.shape) - 1
            return np.sqrt(chi2 / (n * min_dim))


        # Criar lista de nomes exibidos no multiselect
        # Excluir a coluna "rua"
        colunas_filtradas = [col for col in df.columns if col != "Unnamed: 0"]

        # Gerar lista de nomes traduzidos (exibidos)
        variaveis_traduzidas = [nomes_traduzidos.get(col, col.capitalize()) for col in colunas_filtradas]

        # Mapa de nomes exibidos para os nomes reais das colunas
        mapa_nome_exibido_para_coluna = {
            nomes_traduzidos.get(col, col.capitalize()): col for col in colunas_filtradas
        }


        # Sele√ß√£o de vari√°veis com nomes traduzidos
        selected_display_names = st.multiselect("Selecione as vari√°veis para a matriz", variaveis_traduzidas)

        # Mapear de volta para os nomes reais do DataFrame
        selected_vars = [mapa_nome_exibido_para_coluna[nome] for nome in selected_display_names]

        if len(selected_vars) < 2:
            st.warning("Selecione pelo menos duas vari√°veis.")
            st.stop()  # Impede que o c√≥digo continue

        # Criar matriz vazia
        corr_matrix = pd.DataFrame(index=selected_vars, columns=selected_vars, dtype=float)

        for var1 in selected_vars:
            for var2 in selected_vars:
                if var1 == var2:
                    corr_matrix.loc[var1, var2] = 1.0
                elif df[var1].dtype in ['int64', 'float64'] and df[var2].dtype in ['int64', 'float64']:
                    # Correla√ß√£o de Pearson
                    corr_matrix.loc[var1, var2] = df[[var1, var2]].corr().iloc[0, 1]
                elif df[var1].dtype == 'object' and df[var2].dtype == 'object':
                    if df[var1].nunique() > 1 and df[var2].nunique() > 1:
                        corr_matrix.loc[var1, var2] = cramers_v(df[var1], df[var2])
                    else:
                        corr_matrix.loc[var1, var2] = np.nan
                else:
                    # Correla√ß√£o entre categ√≥rica e num√©rica
                    categories = pd.get_dummies(df[var1] if df[var1].dtype == 'object' else df[var2])
                    target = df[var2] if df[var1].dtype == 'object' else df[var1]
                    r_squared = np.mean([np.corrcoef(categories[col], target)[0, 1] ** 2 for col in categories.columns])
                    corr_matrix.loc[var1, var2] = r_squared

        # Preencher NaNs
        corr_matrix = corr_matrix.fillna(0)

        # Trocar nomes das linhas/colunas para os traduzidos, para visualiza√ß√£o
        corr_matrix.index = [nomes_traduzidos.get(v, v.capitalize()) for v in corr_matrix.index]
        corr_matrix.columns = [nomes_traduzidos.get(v, v.capitalize()) for v in corr_matrix.columns]

        # Mostrar gr√°fico
        if not corr_matrix.isnull().values.all():
            fig = px.imshow(
                corr_matrix,
                text_auto=".2f",
                color_continuous_scale="viridis",
                title="Matriz de Correla√ß√£o",
                labels=dict(color="Correla√ß√£o")
            )
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.error("A matriz de correla√ß√£o est√° vazia. Verifique os dados selecionados.")

        st.markdown("---")
        st.caption("¬© 2025 AutoImport Portugal. Todos os direitos reservados.")



